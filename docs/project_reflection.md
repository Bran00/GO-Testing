# Project Reflection: GO+Testing

This document reflects on the structure, tools, and details of the GO+Testing project.

## Project Overview

The GO+Testing project is a simple yet illustrative example of a Go application that demonstrates best practices in testing. The project is divided into two distinct versions, each showcasing a different stage in the evolution of a simple tax calculation service. The primary goal is to provide a clear, hands-on guide to writing effective tests in Go, from basic unit tests to more advanced concepts like fuzzing and mocking.

### Version 1: Simple Tax Calculation

The first version of the project, located in the `1/` directory, introduces a basic `CalculateTax` function. This version serves as a foundation, demonstrating a simple business logic implementation and the use of standard Go testing, including fuzz testing.

**`1/tax.go`**
```go
package tax

func CalculateTax(amount float64) float64 {
	if amount <= 0 {
		return 0
	}
	if amount >= 1000 {
		return 10.0
	}
	return 5.0
}
```

This function is straightforward, but it has multiple conditional paths, making it a good candidate for testing.

### Version 2: Introducing Dependencies and Mocking

The second version, found in the `2/` directory, builds upon the first by introducing a dependency on a `Repository` interface. This showcases how to handle dependencies in Go applications and how to use mocking to isolate the code under test. This is a common scenario in real-world applications where business logic needs to interact with external systems like databases or APIs.

**`2/tax.go`**
```go
package tax

type Repository interface {
	SaveTax(amount float64) error
}

func CalculateTaxAndSave(amount float64, repository Repository) error {
	tax := CalculateTax(amount)
	return repository.SaveTax(tax)
}

func CalculateTax(amount float64) float64 {
	if amount <= 0 {
		return 0
	}
	if amount >= 1000 {
		return 10.0
	}
	return 5.0
}
```

## Project Structure

The project is structured as follows:

```
/home/bran00/software-development/GO+Testing/
├───README.md
├───.git/...
├───1/
│   ├───go.mod
│   ├───tax_test.go
│   ├───tax.go
│   └───testdata/
│       └───fuzz/
│           └───FuzzCalculateTax/
│               ├───3dad565ccd04b681
│               └───5fb97e24f60a8962
├───2/
│   ├───go.mod
│   ├───go.sum
│   ├───repository_mock.go
│   ├───tax_test.go
│   └───tax.go
└───docs/
```

- **`1/`**: Contains the first version of the tax calculation service.
- **`2/`**: Contains the second version of the tax calculation service, which includes a repository dependency.
- **`docs/`**: Contains project documentation.
- **`README.md`**: The main entry point for project information.
- **`testdata/`**: This directory is automatically generated by Go's fuzz testing tooling. It stores interesting values found during fuzzing that caused the test to fail or uncovered a new code path.

## Tools and Technologies

The project utilizes the following tools and technologies:

- **Go**: The programming language used for the application.
- **Go Modules**: For dependency management (`go.mod`, `go.sum`).
- **Go Testing Framework**: The built-in testing framework in Go, used for writing and running tests.
- **Fuzz Testing**: A modern testing technique, integrated into the Go toolchain since Go 1.18, used to find edge cases and vulnerabilities by providing randomized inputs to functions.
- **Mocking**: A technique used to isolate dependencies in tests. In this project, we use a hand-written mock, but tools like `mockery` or `gomock` can automate this.

## Testing Strategies

The project employs a variety of testing strategies to ensure the quality and robustness of the code.

### Unit Testing

Standard unit tests are used to verify the correctness of individual functions with specific inputs.

**`1/tax_test.go`**
```go
package tax

import "testing"

func TestCalculateTax(t *testing.T) {
	amount := 500.0
	expected := 5.0

	result := CalculateTax(amount)

	if result != expected {
		t.Errorf("Expected %f, but got %f", expected, result)
	}
}
```

### Fuzz Testing

Fuzz testing automatically generates a wide range of inputs to test the `CalculateTax` function for unexpected behavior or crashes.

**`1/tax_test.go`**
```go
func FuzzCalculateTax(f *testing.F) {
	seed := []float64{-1, 0, 500, 1000, 1500}
	for _, amount := range seed {
		f.Add(amount)
	}
	f.Fuzz(func(t *testing.T, amount float64) {
		result := CalculateTax(amount)
		if amount <= 0 && result != 0 {
			t.Errorf("Received %f but expected 0", result)
		}
		if amount > 1000 && result != 10.0 {
			t.Errorf("Received %f but expected 10.0", result)
		}
	})
}
```
The `f.Add()` calls provide an initial seed corpus to guide the fuzzer. The fuzzer then uses this to generate new inputs.

### Mocking for Dependency Injection

In Version 2, the `CalculateTaxAndSave` function depends on a `Repository`. To test this function without a real database, we create a mock repository.

**`2/repository_mock.go`**
```go
package tax

import "testing"

type TaxRepositoryMock struct {
	SaveTaxFn func(amount float64) error
}

func (m *TaxRepositoryMock) SaveTax(amount float64) error {
	return m.SaveTaxFn(amount)
}
```

This mock allows us to define the behavior of the `SaveTax` method within our test.

**`2/tax_test.go`**
```go
package tax

import (
	"errors"
	"testing"
)

func TestCalculateTaxAndSave(t *testing.T) {
	repository := &TaxRepositoryMock{}
	repository.SaveTaxFn = func(amount float64) error {
		if amount != 10.0 {
			t.Errorf("Expected 10.0, got %f", amount)
		}
		return nil
	}

	err := CalculateTaxAndSave(1500.0, repository)
	if err != nil {
		t.Errorf("Expected nil, got %v", err)
	}

	// Test error case
	repository.SaveTaxFn = func(amount float64) error {
		return errors.New("error saving tax")
	}

	err = CalculateTaxAndSave(1500.0, repository)
	if err == nil {
		t.Error("Expected an error, but got nil")
	}
}
```
This test verifies that `CalculateTaxAndSave` correctly calculates the tax and calls the repository's `SaveTax` method with the right value. It also tests the error handling path.

## Conclusion

The GO+Testing project, while simple, provides a comprehensive overview of modern Go development and testing practices. It effectively demonstrates the importance of a layered approach to testing, from basic unit tests to more advanced techniques like fuzz testing and mocking. This project serves as a valuable learning resource for anyone looking to improve their Go development and testing skills by providing concrete, runnable examples.